#!/bin/bash
# Distributed under the terms of the GNU General Public License v2

SCRIPTPATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"

source "${SCRIPTPATH}"/_util/isolated-functions.sh || exit 1

if [[ $# -lt 1 ]] ; then
	__helpers_die "${0##*/}: at least one argument needed"
	exit 1
fi

if ! ___eapi_has_prefix_variables; then
	ED=${D}
fi

if ! ___eapi_has_DESTTREE_INSDESTTREE; then
	[[ -n ${DESTTREE} ]] &&
		die "${0##*/}: \${DESTTREE} has been banned for EAPI '$EAPI'; use 'into' instead"
else
	# backwards compatibility
	_E_DESTTREE_=${DESTTREE}
fi

if [[ ! -d ${ED%/}/${_E_DESTTREE_#/}/bin ]] ; then
	install -d "${ED%/}/${_E_DESTTREE_#/}/bin" || { __helpers_die "${0##*/}: failed to install ${ED%/}/${_E_DESTTREE_#/}/bin"; exit 2; }
fi

ret=0

for x in "$@" ; do
	if [[ -e ${x} ]] ; then
		install -m0755 -o ${PORTAGE_INST_UID:-0} -g ${PORTAGE_INST_GID:-0} "${x}" "${ED%/}/${_E_DESTTREE_#/}/bin"
	else
		echo "!!! ${0##*/}: $x does not exist" 1>&2
		false
	fi
	((ret|=$?))
done

[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"
exit ${ret}









        # python-kmod bug: can only recognize the last firmware in modinfo
        # so use the command output of modinfo directly
        ret = []
        for line in Util.cmdCall("/bin/modinfo", kmod_filepath).split("\n"):
            m = re.fullmatch("firmware: +(\\S.*)", line)
            if m is not None:
                ret.append(m.group(1))
        return ret
